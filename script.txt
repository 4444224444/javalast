// script.js
import * as THREE from "three";
import { GLTFLoader } from "GLTFLoader";
import { OrbitControls } from "OrbitControls";
import gsap from "gsap";

// ===============================
// 0. ì „ì—­ ë³€ìˆ˜
// ===============================
let renderer, scene, camera;
let controls;
let starfield;
let starSpeed = { x: 0.00005, y: 0.00007 }; // ë³„ íšŒì „ ì†ë„
let pointsGroup; // ë‡Œ í¬ì¸íŠ¸ í´ë¼ìš°ë“œ
const clickableNodes = []; // ê¸°ì–µ ë…¸ë“œë“¤ (Raycasting ëŒ€ìƒ)
const keywordLabelGroups = []; // ê° ë…¸ë“œë³„ í‚¤ì›Œë“œ ë¼ë²¨ ëª¨ìŒ
const _tmpWorldPos = new THREE.Vector3();

// WASD ìƒíƒœ
const keyState = {
  KeyW: false,
  KeyA: false,
  KeyS: false,
  KeyD: false,
};

// ì´ë™ ì†ë„
let moveSpeed = 0.3;

// ì¹´ë©”ë¼ê°€ ëŒì•„ë‹¤ë‹ ìˆ˜ ìˆëŠ” ë‡Œ ì•ˆìª½ ë²”ìœ„
const BOUNDS = {
  x: 80,
  y: 80,
  z: 80,
};

const isDashboardOpen = { value: false }; // ëŒ€ì‹œë³´ë“œ ì—´ë ¤ ìˆì„ ë•Œ ì´ë™/í´ë¦­ ë§‰ê¸°ìš©
const TARGET_POSITION = new THREE.Vector3(0, 0, 50); // ì¤Œì¸ í›„ ì¹´ë©”ë¼ ìœ„ì¹˜

// Raycaster (ë…¸ë“œ í´ë¦­ìš©)
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// ===============================
// 1. ì´ˆê¸°í™” & ë£¨í”„ ì‹œì‘
// ===============================
init();
animate();

// ===============================
// init : ì”¬ / ì¹´ë©”ë¼ / ë Œë”ëŸ¬ ì„¸íŒ…
// ===============================
function init() {
  const canvas = document.querySelector("#canvas");

  // ëŒ€ì‹œë³´ë“œ ì˜¤ë²„ë ˆì´ ì´ˆê¸° ìƒíƒœ ê°•ì œ ìˆ¨ê¸°ê¸°
  const overlay = document.getElementById("dashboard-overlay");
  if (overlay) {
    overlay.classList.add("hidden");
    overlay.style.opacity = 0;
  }

  renderer = new THREE.WebGLRenderer({
    canvas,
    antialias: true,
    alpha: true,
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);

  scene = new THREE.Scene();
  scene.background = new THREE.Color("#000000");

  camera = new THREE.PerspectiveCamera(
    50,
    window.innerWidth / window.innerHeight,
    0.1,
    2000
  );
  camera.position.set(0, 0, 400);
  camera.lookAt(0, 0, 0);

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
  directionalLight.position.set(1, 1, 1);
  scene.add(directionalLight);

  createStarfield();
  loadBrainModel();
  startClock();

  window.addEventListener("resize", onWindowResize);
}

// ===============================
// 2. ë³„ ë°°ê²½ ë§Œë“¤ê¸°
// ===============================
function createStarfield() {
  const starVertices = [];

  for (let i = 0; i < 10000; i++) {
    const x = THREE.MathUtils.randFloatSpread(1500);
    const y = THREE.MathUtils.randFloatSpread(1500);
    const z = THREE.MathUtils.randFloatSpread(1500);
    starVertices.push(x, y, z);
  }

  const starGeometry = new THREE.BufferGeometry();
  starGeometry.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(starVertices, 3)
  );

  const starMaterial = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.5,
    blending: THREE.AdditiveBlending,
    transparent: true,
    opacity: 0.8,
  });

  starfield = new THREE.Points(starGeometry, starMaterial);
  scene.add(starfield);
}

// ===============================
// 3. ê¸°ì–µ ë…¸ë“œ ë°ì´í„°
// ===============================
const MEMORY_NODES = [
  {
    name: "ì „ë‘ì—½ (Frontal Lobe)",
    position: new THREE.Vector3(10, 55, -40),

    // ê¸°ë³¸/ë””í´íŠ¸ ì´ë¯¸ì§€
    baseImage: "images/frontal_default.jpg",

    // ë¼ë²¨ + ë¼ë²¨ë³„ ì´ë¯¸ì§€
    keywords: [
      {
        key: "threejs",
        label: "three.js",
        image: "images/frontal_threejs.jpg",
      },
      {
        key: "webdev",
        label: "web dev",
        image: "images/frontal_web.jpg",
      },
      {
        key: "portfolio",
        label: "portfolio",
        image: "images/frontal_portfolio.jpg",
      },
    ],

    // ëŒ€ì‹œë³´ë“œìš© ìš”ì•½ ì •ë³´
    summaryTitle: "FRONTAL LOBE // PLANNING",
    summaryText: "ì¥ê¸° ê³„íš, ì‚¬ì´ë“œ í”„ë¡œì íŠ¸, ë¯¸ë˜ ì„¤ê³„ì™€ ê´€ë ¨ëœ ê¸°ì–µë“¤ì„ ì €ì¥í•˜ëŠ” ì˜ì—­.",
    tags: ["planning", "project", "future"],

    // ëŒ€ì‹œë³´ë“œ ë³¸ë¬¸ HTML
    content: `
      <h2>ì „ë‘ì—½: ê³„íšê³¼ ì‹¤í–‰</h2>
      <p>ì—¬ê¸°ì— ê¸´ ì„¤ëª… HTML...</p>
    `,

    coreStyle: {
      shape: "sphere",
      size: 0.75,
      color: 0x38bdf8,
      opacity: 0.4,
    },
    satelliteStyle: {
      color: 0x38bdf8,
      size: 0.14,
      opacity: 0.7,
    },
    labelStyle: {
      color: "#38bdf8",
      fontSize: "11px",
      className: "label-frontal",
    },
  },
  // í•„ìš”í•˜ë©´ ì—¬ê¸° ë‹¤ë¥¸ ë…¸ë“œë“¤ ì¶”ê°€
];

// ===============================
// 4-A. í‚¤ì›Œë“œ ë¼ë²¨ ë§ (ì”¬ ë°– UIìš©, ë…¸ë“œ ì£¼ë³€ ë– ë‹¤ë‹ˆëŠ” ë¼ë²¨)
// ===============================
function setupKeywordRing(coreMesh, nodeData) {
  const keywords = nodeData.keywords;
  if (!keywords || keywords.length === 0) return;

  const uiContainer = document.getElementById("ui-container") || document.body;
  const group = { node: coreMesh, labels: [] };
  const labelOpts = nodeData.labelStyle || {};

  const count = keywords.length;
  for (let i = 0; i < count; i++) {
    const k = keywords[i];

    const labelText = typeof k === "string" ? k : k.label;
    const labelKey = typeof k === "string" ? k : (k.key || k.label);
    const labelImage = typeof k === "string" ? null : k.image;

    const el = document.createElement("div");
    el.className = "keyword-label";
    if (labelOpts.className) el.classList.add(labelOpts.className);

    el.textContent = labelText;

    el.dataset.nodeName = nodeData.name;
    el.dataset.keywordKey = labelKey;
    if (labelImage) {
      el.dataset.image = labelImage;
    }

    if (labelOpts.color) el.style.color = labelOpts.color;
    if (labelOpts.fontSize) el.style.fontSize = labelOpts.fontSize;

    uiContainer.appendChild(el);

    const angle = (i / count) * Math.PI * 2;
    group.labels.push({ el, angle });
  }

  keywordLabelGroups.push(group);
}

// ===============================
// 4-B. í‚¤ì›Œë“œ ë¼ë²¨ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
// ===============================
function updateKeywordLabels(timeSec) {
  if (keywordLabelGroups.length === 0 || !camera) return;

  const halfW = window.innerWidth / 2;
  const halfH = window.innerHeight / 2;

  keywordLabelGroups.forEach((group) => {
    const { node, labels } = group;

    node.getWorldPosition(_tmpWorldPos);

    const camDist = camera.position.distanceTo(_tmpWorldPos);

    if (camDist > 90) {
      labels.forEach(({ el }) => {
        el.style.opacity = 0;
      });
      return;
    }

    const proj = _tmpWorldPos.clone().project(camera);
    if (proj.z > 1) {
      labels.forEach(({ el }) => {
        el.style.opacity = 0;
      });
      return;
    }

    const baseX = proj.x * halfW + halfW;
    const baseY = -proj.y * halfH + halfH;

    const vis = THREE.MathUtils.clamp(1 - (camDist - 75) / 50, 0, 1);

    labels.forEach(({ el, angle }) => {
      const baseRadius = 110;
      const pulseAmp = 30;

      const pulse = Math.sin(timeSec * 1.4 + angle * 2.5) * pulseAmp;
      const r = baseRadius + pulse;

      const sx = baseX + Math.cos(angle) * r;
      const sy = baseY + Math.sin(angle) * r * 0.7;

      el.style.left = `${sx}px`;
      el.style.top = `${sy}px`;
      el.style.opacity = vis;
    });
  });
}

// ===============================
// 4-C. ê¸°ì–µ ë…¸ë“œ ìƒì„±
// ===============================
function createMemoryNodes() {
  MEMORY_NODES.forEach((nodeData) => {
    const group = new THREE.Group();
    group.position.copy(nodeData.position);

    const coreStyle = nodeData.coreStyle || {};
    const satStyle = nodeData.satelliteStyle || {};

    const coreSize = coreStyle.size ?? 0.55;
    const coreColor = coreStyle.color ?? 0xffffff;
    const coreOpacity = coreStyle.opacity ?? 0.28;
    const coreShape = coreStyle.shape ?? "sphere";

    const satColor = satStyle.color ?? 0xffffff;
    const satSize = satStyle.size ?? 0.12;
    const satOpacity = satStyle.opacity ?? 0.55;

    let coreGeo;
    switch (coreShape) {
      case "cube":
        coreGeo = new THREE.BoxGeometry(coreSize, coreSize, coreSize);
        break;
      case "diamond":
        coreGeo = new THREE.OctahedronGeometry(coreSize);
        break;
      case "sphere":
      default:
        coreGeo = new THREE.SphereGeometry(coreSize, 24, 24);
        break;
    }

    const coreMat = new THREE.MeshBasicMaterial({
      color: coreColor,
      transparent: true,
      opacity: coreOpacity,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });

    const coreMesh = new THREE.Mesh(coreGeo, coreMat);
    coreMesh.name = nodeData.name;
    coreMesh.userData = {
      content: nodeData.content,
      image: nodeData.image || nodeData.baseImage,
      group,
      nodeData, // ëŒ€ì‹œë³´ë“œìš© ì „ì²´ ë°ì´í„°
    };
    group.add(coreMesh);

    const satelliteCount = 70;
    const satPositions = new Float32Array(satelliteCount * 3);
    const satVecs = [];

    for (let i = 0; i < satelliteCount; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const dir = new THREE.Vector3(
        Math.sin(phi) * Math.cos(theta),
        Math.sin(phi) * Math.sin(theta),
        Math.cos(phi)
      );

      const radius = THREE.MathUtils.randFloat(4, 16);
      dir.multiplyScalar(radius);

      satVecs.push(dir.clone());
      const idx = i * 3;
      satPositions[idx] = dir.x;
      satPositions[idx + 1] = dir.y;
      satPositions[idx + 2] = dir.z;
    }

    const satGeo = new THREE.BufferGeometry();
    satGeo.setAttribute("position", new THREE.BufferAttribute(satPositions, 3));

    const satMat = new THREE.PointsMaterial({
      color: satColor,
      size: satSize,
      transparent: true,
      opacity: satOpacity,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });

    const satellites = new THREE.Points(satGeo, satMat);
    group.add(satellites);

    const coreLinks = satelliteCount;
    const extraLinks = Math.floor(satelliteCount * 0.8);
    const segmentCount = coreLinks + extraLinks;
    const linePositions = new Float32Array(segmentCount * 2 * 3);

    let offset = 0;

    for (let i = 0; i < satelliteCount; i++) {
      const v = satVecs[i];

      linePositions[offset++] = 0;
      linePositions[offset++] = 0;
      linePositions[offset++] = 0;

      linePositions[offset++] = v.x;
      linePositions[offset++] = v.y;
      linePositions[offset++] = v.z;
    }

    for (let i = 0; i < extraLinks; i++) {
      const a = Math.floor(Math.random() * satelliteCount);
      const b = Math.floor(Math.random() * satelliteCount);
      if (a === b) continue;

      const va = satVecs[a];
      const vb = satVecs[b];

      linePositions[offset++] = va.x;
      linePositions[offset++] = va.y;
      linePositions[offset++] = va.z;

      linePositions[offset++] = vb.x;
      linePositions[offset++] = vb.y;
      linePositions[offset++] = vb.z;
    }

    const lineGeo = new THREE.BufferGeometry();
    lineGeo.setAttribute(
      "position",
      new THREE.BufferAttribute(linePositions, 3)
    );

    const lineMat = new THREE.LineBasicMaterial({
      color: satColor,
      transparent: true,
      opacity: 0.22,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });

    const filaments = new THREE.LineSegments(lineGeo, lineMat);
    group.add(filaments);

    gsap.to(group.scale, {
      x: 1.45,
      y: 1.45,
      z: 1.45,
      duration: 2.0,
      repeat: -1,
      yoyo: true,
      ease: "sine.inOut",
    });

    gsap.to(group.rotation, {
      y: "+=" + Math.PI * 2,
      duration: 26,
      repeat: -1,
      ease: "none",
    });
    gsap.to(group.rotation, {
      x: "+=" + Math.PI * 2,
      duration: 40,
      repeat: -1,
      ease: "none",
    });

    gsap.to([satMat, lineMat], {
      opacity: (i) => (i === 0 ? satOpacity + 0.2 : 0.28),
      duration: 1.6,
      repeat: -1,
      yoyo: true,
      ease: "sine.inOut",
      stagger: 0.15,
    });

    // ë¼ë²¨ ë§ ìƒì„± (ì”¬ ë°– UI)
    setupKeywordRing(coreMesh, nodeData);

    scene.add(group);
    clickableNodes.push(coreMesh);
  });
}

// ===============================
// 5. ë‡Œ GLTF ëª¨ë¸ ë¡œë“œ
// ===============================
function loadBrainModel() {
  const loader = new GLTFLoader();

  loader.load(
    "models/scene.gltf",
    (gltf) => {
      const model = gltf.scene;

      pointsGroup = new THREE.Group();
      const linesGroup = new THREE.Group();

      model.traverse((object) => {
        if (object.isMesh) {
          const pointsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.03,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.75,
            sizeAttenuation: true,
          });
          const points = new THREE.Points(object.geometry, pointsMaterial);
          pointsGroup.add(points);

          const lineMaterial = new THREE.LineBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.1,
          });
          const wireframeGeom = new THREE.WireframeGeometry(object.geometry);
          const lines = new THREE.LineSegments(wireframeGeom, lineMaterial);
          linesGroup.add(lines);

          object.visible = false;
        }
      });

      pointsGroup.rotation.x = -Math.PI / 2;
      linesGroup.rotation.x = -Math.PI / 2;

      scene.add(pointsGroup);
      scene.add(linesGroup);

      createMemoryNodes();

      const startScreen = document.getElementById("start-screen");
      if (startScreen) {
        startScreen.addEventListener("click", startExploration);
      }
    },
    undefined,
    (error) => {
      console.error("ëª¨ë¸ ë¡œë”© ì¤‘ ì—ëŸ¬:", error);
    }
  );
}

// ===============================
// 6. íƒì‚¬ ì‹œì‘
// ===============================
function startExploration() {
  const startScreen = document.getElementById("start-screen");
  const titleBox = document.getElementById("title-box");
  const subtitleBox = document.getElementById("subtitle-box");
  const hud = document.getElementById("hud");
  const devConsole = document.getElementById("dev-console");
  const fpUi = document.getElementById("fp-ui");

  const tl = gsap.timeline();

  [startScreen, titleBox, subtitleBox].forEach((el) => {
    if (!el) return;
    tl.to(
      el,
      {
        y: 80,
        opacity: 0,
        duration: 0.45,
        ease: "power2.in",
        onComplete: () => {
          el.style.display = "none";
        },
      },
      0
    );
  });

  tl.to(
    camera.position,
    {
      x: TARGET_POSITION.x,
      y: TARGET_POSITION.y,
      z: TARGET_POSITION.z,
      duration: 4,
      ease: "power3.inOut",
      onUpdate: () => {
        if (pointsGroup) {
          camera.lookAt(pointsGroup.position);
        } else {
          camera.lookAt(0, 0, 0);
        }
      },
    },
    0.1
  );

  if (pointsGroup) {
    tl.to(
      pointsGroup.scale,
      {
        x: 1.2,
        y: 1.2,
        z: 1.2,
        duration: 4,
        ease: "power3.inOut",
      },
      0.1
    );
  }

  tl.call(() => {
    setupControls();

    if (fpUi) {
      fpUi.classList.add("active");
    }

    const uiToShow = [];
    if (hud) uiToShow.push(hud);
    if (devConsole) uiToShow.push(devConsole);

    if (uiToShow.length > 0) {
      gsap.fromTo(
        uiToShow,
        { x: -40, opacity: 0 },
        {
          x: 0,
          opacity: 1,
          duration: 0.35,
          ease: "power2.out",
          onStart: () => {
            uiToShow.forEach((el) => (el.style.pointerEvents = "auto"));
          },
        }
      );
    }
  });
}

// ===============================
// 7. OrbitControls + ì´ë²¤íŠ¸ ì„¸íŒ…
// ===============================
function setupControls() {
  controls = new OrbitControls(camera, renderer.domElement);

  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.rotateSpeed = 0.7;
  controls.zoomSpeed = 0.6;

  controls.minDistance = 25;
  controls.maxDistance = 140;

  if (pointsGroup) {
    controls.target.copy(pointsGroup.position);
  } else {
    controls.target.set(0, 0, 0);
  }

  controls.enablePan = false;
  controls.enableRotate = true;
  controls.enableZoom = true;
  controls.autoRotate = false;

  controls.mouseButtons = {
    LEFT: THREE.MOUSE.ROTATE,
    MIDDLE: THREE.MOUSE.DOLLY,
    RIGHT: THREE.MOUSE.DOLLY,
  };

  const canvas = document.querySelector("#canvas");
  canvas.addEventListener("click", onCanvasClick);
  canvas.addEventListener("mousemove", onCanvasMouseMove);
  canvas.addEventListener("mouseleave", onCanvasMouseLeave);

  window.addEventListener("keydown", onKeyDown);
  window.addEventListener("keyup", onKeyUp);

  const closeBtn = document.getElementById("close-dashboard");
  if (closeBtn) {
    closeBtn.addEventListener("click", closeDashboard);
  }

  controls.update();
}

// ===============================
// 8. í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
// ===============================
function onKeyDown(event) {
  if (isDashboardOpen.value) return;
  if (keyState.hasOwnProperty(event.code)) {
    keyState[event.code] = true;
  }
}

function onKeyUp(event) {
  if (keyState.hasOwnProperty(event.code)) {
    keyState[event.code] = false;
  }
}

// ===============================
// 9. ë…¸ë“œ í”„ë¦¬ë·° (ë§ˆìš°ìŠ¤ í˜¸ë²„)
// ===============================
let hoveredNode = null;

function onCanvasMouseMove(event) {
  if (isDashboardOpen.value) return;

  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(clickableNodes);

  if (intersects.length > 0) {
    const node = intersects[0].object;
    hoveredNode = node;
    updateNodePreview(node);
  } else {
    hoveredNode = null;
    hideNodePreview();
  }
}

function onCanvasMouseLeave() {
  hoveredNode = null;
  hideNodePreview();
}

function updateNodePreview(node) {
  const preview = document.getElementById("node-preview");
  const img = document.getElementById("node-preview-img");
  if (!preview || !img) return;

  if (node.userData.image) {
    img.src = node.userData.image;
    img.style.backgroundColor = "transparent";
  } else {
    img.removeAttribute("src");
    img.style.backgroundColor = "#444";
  }

  const vector = node.position.clone().project(camera);
  const halfW = window.innerWidth / 2;
  const halfH = window.innerHeight / 2;

  const screenX = vector.x * halfW + halfW;
  const screenY = -vector.y * halfH + halfH;

  preview.style.left = screenX + 20 + "px";
  preview.style.top = screenY - 20 + "px";

  preview.classList.remove("hidden");
  preview.style.opacity = 1;
}

function hideNodePreview() {
  const preview = document.getElementById("node-preview");
  if (!preview) return;
  preview.classList.add("hidden");
  preview.style.opacity = 0;
}

// ===============================
// 10. WASD ì´ë™
// ===============================
function handleMovement() {
  if (!controls || isDashboardOpen.value) return;

  const forward = new THREE.Vector3();
  camera.getWorldDirection(forward);
  forward.y = 0;
  forward.normalize();

  const right = new THREE.Vector3();
  right.crossVectors(forward, camera.up).normalize();

  const move = new THREE.Vector3();

  if (keyState.KeyW) move.add(forward);
  if (keyState.KeyS) move.sub(forward);
  if (keyState.KeyA) move.sub(right);
  if (keyState.KeyD) move.add(right);

  if (move.lengthSq() > 0) {
    move.normalize().multiplyScalar(moveSpeed);

    const nextPos = camera.position.clone().add(move);

    nextPos.x = THREE.MathUtils.clamp(nextPos.x, -BOUNDS.x, BOUNDS.x);
    nextPos.y = THREE.MathUtils.clamp(nextPos.y, -BOUNDS.y, BOUNDS.y);
    nextPos.z = THREE.MathUtils.clamp(nextPos.z, -BOUNDS.z, BOUNDS.z);

    const appliedDelta = nextPos.clone().sub(camera.position);

    camera.position.copy(nextPos);
    controls.target.add(appliedDelta);
  }
}

// ===============================
// 11. HUD: ë…¸ë“œ ê±°ë¦¬ í‘œì‹œ
// ===============================
function updateHUD() {
  const distanceLabel = document.getElementById("distance-label");
  if (!distanceLabel || clickableNodes.length === 0) return;

  let minDist = Infinity;

  clickableNodes.forEach((node) => {
    const dist = camera.position.distanceTo(node.position);
    if (dist < minDist) minDist = dist;
  });

  if (minDist === Infinity) {
    distanceLabel.textContent = "NODE DISTANCE: --";
  } else {
    const rounded = Math.round(minDist);
    distanceLabel.textContent = `NODE DISTANCE: ${rounded}`;
  }
}

// ===============================
// 12. ì‹œê³„ (ì˜¤ëŠ˜ ë‚ ì§œ + ì‹œê°„)
// ===============================
function startClock() {
  const clockEl = document.getElementById("clock");
  if (!clockEl) return;

  function update() {
    const now = new Date();

    const yyyy = now.getFullYear();
    const mm = String(now.getMonth() + 1).padStart(2, "0");
    const dd = String(now.getDate()).padStart(2, "0");
    const hh = String(now.getHours()).padStart(2, "0");
    const mi = String(now.getMinutes()).padStart(2, "0");
    const ss = String(now.getSeconds()).padStart(2, "0");

    clockEl.textContent = `${yyyy}-${mm}-${dd} ${hh}:${mi}:${ss}`;
  }

  update();
  setInterval(update, 1000);
}

// ===============================
// 13. ìº”ë²„ìŠ¤ í´ë¦­ â†’ ë…¸ë“œ ì„ íƒ
// ===============================
function onCanvasClick(event) {
  if (isDashboardOpen.value) return;

  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(clickableNodes);

  if (intersects.length > 0) {
    const node = intersects[0].object;
    openDashboardWithAnimation(node);
  }
}

// ===============================
// 14. ëŒ€ì‹œë³´ë“œ ë‚´ìš© ì„¸íŒ…
// ===============================
function buildDashboardForNode(node) {
  const data = node.userData?.nodeData;
  if (!data) return;

  const nodeNameEl = document.getElementById("dashboard-node-name");
  const mainTitleEl = document.getElementById("dashboard-main-title");
  const mainTextEl = document.getElementById("dashboard-main-text");
  const dashTitleEl = document.getElementById("dash-node-title");
  const tagsWrap = document.getElementById("dash-node-tags");
  const orbitWrap = document.getElementById("dash-node-orbit-labels");
  const bodyEl = document.getElementById("dashboard-body");
  const photoEl = document.getElementById("dashboard-photo");
  const coreMini = document.querySelector(".node-orbit-core");

  // ğŸ”¹ ìƒë‹¨ ë©”íƒ€
  if (nodeNameEl) nodeNameEl.textContent = data.name || "NODE";

  // ğŸ”¹ ì™¼ìª½ í…ìŠ¤íŠ¸ íŒ¨ë„
  const titleText = data.summaryTitle || data.name || "UNTITLED NODE";
  const summaryText = data.summaryText || "";
  if (mainTitleEl) mainTitleEl.textContent = titleText;
  if (mainTextEl) mainTextEl.textContent = summaryText;

  // ğŸ”¹ ì˜¤ë¥¸ìª½ í”„ë¡œí•„ ì¹´ë“œ
  if (dashTitleEl) dashTitleEl.textContent = titleText;

  if (tagsWrap) {
    tagsWrap.innerHTML = "";
    if (Array.isArray(data.tags)) {
      data.tags.forEach((tag) => {
        const span = document.createElement("span");
        span.className = "dash-tag";
        span.textContent = tag;
        tagsWrap.appendChild(span);
      });
    }
  }

  // ğŸ”¹ DESCRIPTION ì¹´ë“œ
  if (bodyEl) {
    bodyEl.innerHTML = data.content || "";
  }

  // ğŸ”¹ ë¯¸ë‹ˆ ë…¸ë“œ ì½”ì–´ ìƒ‰ê¹” (ì‹¤ì œ ë…¸ë“œ ì»¬ëŸ¬ë‘ ë§ì¶”ê¸°)
  if (coreMini) {
    coreMini.style.removeProperty("background-color");
    coreMini.style.removeProperty("box-shadow");

    const coreColorNum = data.coreStyle?.color;
    if (typeof coreColorNum === "number") {
      const hex = "#" + coreColorNum.toString(16).padStart(6, "0");
      coreMini.style.backgroundColor = hex;
      coreMini.style.boxShadow = `0 0 14px ${hex}`;
    } else {
      // ê¸°ë³¸ ìƒ‰
      coreMini.style.backgroundColor = "#38bdf8";
      coreMini.style.boxShadow = "0 0 12px rgba(56,189,248,0.9)";
    }
  }

  // ğŸ”¹ ê¸°ë³¸ ì‚¬ì§„ ì„¸íŒ…
  if (photoEl) {
    const defaultImg =
      data.baseImage ||
      (Array.isArray(data.keywords) && data.keywords[0]?.image) ||
      node.userData.image ||
      "";
    if (defaultImg) {
      photoEl.src = defaultImg;
    } else {
      photoEl.removeAttribute("src");
    }
  }

  // ğŸ”¹ MEMORY ORBIT ë¼ë²¨ë“¤ (ë¯¸ë‹ˆ ë…¸ë“œ ì£¼ë³€ì— ì›í˜• ë°°ì¹˜ + í´ë¦­ ì‹œ ì´ë¯¸ì§€ ë³€ê²½)
  if (orbitWrap) {
    orbitWrap.innerHTML = "";

    if (Array.isArray(data.keywords) && data.keywords.length > 0) {
      const total = data.keywords.length;
      const radius = 38; // % ê¸°ì¤€ ë°˜ê²½ (node-orbit ê¸°ì¤€)

      data.keywords.forEach((k, idx) => {
        const labelText = typeof k === "string" ? k : k.label;
        const imgPath = typeof k === "string" ? null : k.image;

        const angle = (idx / total) * Math.PI * 2; // 0 ~ 2Ï€

        const btn = document.createElement("button");
        btn.className = "dash-orbit-label";
        btn.textContent = labelText;

        // ğŸ”¸ ìœ„ì¹˜: node-orbit ì¤‘ì•™(50%,50%) ê¸°ì¤€ìœ¼ë¡œ ì›í˜• ë°°ì¹˜
        btn.style.position = "absolute";
        const x = 50 + Math.cos(angle) * radius;
        const y = 50 + Math.sin(angle) * radius;
        btn.style.left = `${x}%`;
        btn.style.top = `${y}%`;
        btn.style.transform = "translate(-50%, -50%)";

        // ì²« ë²ˆì§¸ ë¼ë²¨ì€ ê¸°ë³¸ active
        if (idx === 0) {
          btn.classList.add("active");
        }

        // ğŸ”¸ í´ë¦­ ì‹œ: active í† ê¸€ + ì™¼ìª½ ì´ë¯¸ì§€ ë³€ê²½
        btn.addEventListener("click", () => {
          orbitWrap
            .querySelectorAll(".dash-orbit-label.active")
            .forEach((el) => el.classList.remove("active"));
          btn.classList.add("active");

          if (photoEl) {
            const targetImg =
              imgPath ||
              data.baseImage ||
              (Array.isArray(data.keywords) &&
                data.keywords[0] &&
                data.keywords[0].image) ||
              node.userData.image ||
              "";
            if (targetImg) {
              photoEl.src = targetImg;
            }
          }
        });

        orbitWrap.appendChild(btn);
      });
    }
  }
}

// ===============================
// 15. ë…¸ë“œ í´ë¦­ ì‹œ ëŒ€ì‹œë³´ë“œ ì˜¤í”ˆ
// ===============================
function openDashboardWithAnimation(node) {
  const overlay = document.getElementById("dashboard-overlay");
  const contentDiv = document.getElementById("dashboard-content");
  const hud = document.getElementById("hud");
  const fpUi = document.getElementById("fp-ui");
  const preview = document.getElementById("node-preview");
  const img = document.getElementById("node-preview-img");
  const devConsole = document.getElementById("dev-console");

  if (!overlay || !contentDiv) return;

  // ëŒ€ì‹œë³´ë“œ ë‚´ë¶€ ë‚´ìš© ì„¸íŒ…
  buildDashboardForNode(node);

  // ì‘ì€ í”„ë¦¬ë·° ì´ë¯¸ì§€
  if (img && node.userData.image) {
    img.src = node.userData.image;
  }

  if (preview) {
    preview.classList.remove("hidden");
    preview.style.opacity = 1;
  }

  overlay.classList.remove("hidden");

  const tl = gsap.timeline({
    onComplete: () => {
      isDashboardOpen.value = true;
    },
  });

  if (preview) {
    tl.to(preview, {
      duration: 0.5,
      left: "50%",
      top: "50%",
      xPercent: -50,
      yPercent: -50,
      scale: 1.8,
      ease: "none",
    });
  }

  const slideOutTargets = [];
  if (hud) slideOutTargets.push(hud);
  if (devConsole) slideOutTargets.push(devConsole);

  if (slideOutTargets.length > 0) {
    tl.to(
      slideOutTargets,
      {
        duration: 0.35,
        opacity: 0,
        x: -40,
        ease: "none",
      },
      "<"
    );
  }

  if (fpUi) {
    tl.to(
      fpUi,
      {
        duration: 0.35,
        opacity: 0,
        ease: "none",
      },
      "<"
    );
  }

  if (preview) {
    tl.to(preview, {
      duration: 0.25,
      opacity: 0,
      ease: "none",
    });
  }

  tl.fromTo(
    overlay,
    { opacity: 0 },
    { opacity: 1, duration: 0.35, ease: "none" },
    "-=0.1"
  );

  tl.fromTo(
    overlay,
    { xPercent: -8 },
    { xPercent: 0, duration: 0.35, ease: "none" },
    "-=0.35"
  );

  tl.fromTo(
    contentDiv,
    { xPercent: 10, opacity: 0 },
    { xPercent: 0, opacity: 1, duration: 0.35, ease: "none" },
    "-=0.3"
  );

  tl.set(preview, {
    opacity: 0,
    clearProps: "left,top,transform",
  });
}

// ===============================
// 16. ëŒ€ì‹œë³´ë“œ ë‹«ê¸°
// ===============================
function closeDashboard() {
  const overlay = document.getElementById("dashboard-overlay");
  const hud = document.getElementById("hud");
  const fpUi = document.getElementById("fp-ui");
  const devConsole = document.getElementById("dev-console");

  if (!overlay) return;

  const tl = gsap.timeline({
    onComplete: () => {
      overlay.classList.add("hidden");
      overlay.style.opacity = 0;
      isDashboardOpen.value = false;
    },
  });

  tl.to(overlay, {
    duration: 0.35,
    opacity: 0,
    ease: "none",
  });

  const slideInTargets = [];
  if (hud) slideInTargets.push(hud);
  if (devConsole) slideInTargets.push(devConsole);

  if (slideInTargets.length > 0) {
    tl.fromTo(
      slideInTargets,
      { opacity: 0, x: -40 },
      {
        opacity: 1,
        x: 0,
        duration: 0.35,
        ease: "none",
      },
      "-=0.2"
    );
  }

  if (fpUi) {
    tl.fromTo(
      fpUi,
      { opacity: 0 },
      {
        opacity: 0.85,
        duration: 0.35,
        ease: "none",
      },
      "-=0.25"
    );
  }

  if (hud) hud.classList.remove("fade-out");
}

// ===============================
// 17. ë Œë”ë§ ë£¨í”„
// ===============================
function animate() {
  requestAnimationFrame(animate);

  const timeSec = performance.now() * 0.001;

  if (starfield) {
    starfield.rotation.x += starSpeed.x;
    starfield.rotation.y += starSpeed.y;
  }

  if (controls) {
    controls.update();
    handleMovement();
    updateHUD();
  }

  updateKeywordLabels(timeSec);

  renderer.render(scene, camera);
}

// ===============================
// 18. ì°½ í¬ê¸° ë³€ê²½ ëŒ€ì‘
// ===============================
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// ===============================
// 19. DEV CONSOLE: PARAM LAB
// ===============================
const devRunBtn = document.getElementById("dev-run");
if (devRunBtn) {
  devRunBtn.addEventListener("click", runDevScript);
}

function runDevScript() {
  const textarea = document.getElementById("dev-input");
  if (!textarea) return;

  const lines = textarea.value.split("\n");

  lines.forEach((rawLine) => {
    const line = rawLine.trim();
    if (!line) return;
    if (line.startsWith("//")) return;

    const match = /^(\w+)\.(\w+)\((.*)\)$/.exec(line);
    if (!match) return;

    const objName = match[1];
    const methodName = match[2];
    const argString = match[3].trim();

    const args = argString.length
      ? argString
          .split(",")
          .map((s) => s.trim())
          .filter((s) => s.length > 0)
          .map((token) => {
            if (
              (token.startsWith('"') && token.endsWith('"')) ||
              (token.startsWith("'") && token.endsWith("'"))
            ) {
              return token.slice(1, -1);
            }
            const num = Number(token);
            if (!Number.isNaN(num)) return num;
            return token;
          })
      : [];

    applyDevCall(objName, methodName, args);
  });
}

function applyDevCall(obj, method, args) {
  if (obj === "scene" && method === "bg" && typeof args[0] === "string") {
    try {
      scene.background = new THREE.Color(args[0]);
      document.body.style.backgroundColor = args[0];
    } catch (e) {}
    return;
  }

  if (obj === "brain" && pointsGroup) {
    if (method === "moveTo") {
      const [x, y, z] = args;
      if (typeof x === "number") pointsGroup.position.x = x;
      if (typeof y === "number") pointsGroup.position.y = y;
      if (typeof z === "number") pointsGroup.position.z = z;
      return;
    }
    if (method === "offset") {
      const [dx, dy, dz] = args;
      if (typeof dx === "number") pointsGroup.position.x += dx;
      if (typeof dy === "number") pointsGroup.position.y += dy;
      if (typeof dz === "number") pointsGroup.position.z += dz;
      return;
    }
  }

  if (obj === "player" && method === "speed" && typeof args[0] === "number") {
    moveSpeed = args[0];
    return;
  }

  if (obj === "stars" && method === "spin") {
    const [sx, sy] = args;
    if (typeof sx === "number") starSpeed.x = sx;
    if (typeof sy === "number") starSpeed.y = sy;
    return;
  }

  if (obj === "bounds" && method === "cage" && typeof args[0] === "number") {
    const v = Math.abs(args[0]);
    BOUNDS.x = v;
    BOUNDS.y = v;
    BOUNDS.z = v;
    return;
  }
}
